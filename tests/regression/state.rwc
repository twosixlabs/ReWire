device top_level:

inputs [("__in0",1)]
outputs [("__out0",1)]
states [("__st0",1)]

$Pure.dispatch :: W1 -> W1 -> W3
$Pure.dispatch $0 $1 = 3'case {1'$1, 1'$0} of
    {1'@, 1'@} -> Main.loop

$Pure.start :: W3
$Pure.start  = 3'h6

$LL.Main.loop :: W1 -> W1 -> W3
$LL.Main.loop $0 $1 = {1'h1, 1'$0, 1'$1}

$LL.Main.loop2 :: W1 -> W1 -> W3
$LL.Main.loop2 $0 $1 = 3'case {1'$0, 1'$1} of
    {1'@, 1'@} -> $LL.Main.loop

$LL.Main.loop3 :: W3 -> W3
$LL.Main.loop3 $0 = 3'case 3'$0 of
    {1'h0, 1'@, 1'@} -> $LL.Main.loop2

$LL.Main.loop4 :: W1 -> W1 -> W3
$LL.Main.loop4 $0 $1 = {1'h0, 1'$0, 1'$1}

$LL.Main.loop6 :: W2 -> W3
$LL.Main.loop6 $0 = 3'case 2'$0 of
    {1'@, 1'@} -> $LL.Main.loop4

$LL.Main.stateAction1 :: W1 -> W1 -> W1 -> W2
$LL.Main.stateAction1 $0 $1 $2 = {1'$1, 1'case 1'case {1'$0, 1'$1} of {1'@, 1'@} -> XOr of {1'@} -> MSBit}

$LL.Main.stateAction12 :: W1 -> W2 -> W2
$LL.Main.stateAction12 $0 $1 = 2'case {1'$0, 2'$1} of
    {1'@, 1'@, 1'@} -> $LL.Main.stateAction1

Main.loop :: W1 -> W1 -> W3
Main.loop $0 $1 = 3'case 3'case 2'case {1'$0, 1'$1} of
        {1'@, 1'@} -> Main.stateAction of
      {2'@} -> $LL.Main.loop6 of
    {3'@} -> $LL.Main.loop3

Main.stateAction :: W1 -> W1 -> W2
Main.stateAction $0 $1 = 2'case {1'$0, 1'$1, 1'$1} of
    {1'@, 2'@} -> $LL.Main.stateAction12